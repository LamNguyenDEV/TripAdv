/**
* Bootstrap.js
* Von Neumann machine implementation
*
* 1) Use at your own risk - uncontrollable replication may result.
* 2) Do not modify bootstrap or core modules directly - extend using modularity.
* 3) First do no harm. To add without discernment is less than nothing.
* 4) Hidden non-deterministic states are not allowed.
*
*/

const crypto = require('crypto')
const cjson = require('circular-json')
const moment = require('moment')
const uuid = require('uuid/v4')
const diff = require('deep-object-diff')
const processes = require('os').cpus().length

var machineOptions = {

  debug: false,
  cells: 3, // Default cell count
  dimension: 3, // Default dimension
  bytes: 512, // Default bytes per cell
  currencyUnit: 'USD',
  memoryUnit: 'MB',
  maxOps: 32, // Max operations allowed for the machine
  maxDuration: 1000, // Max duration in ms
  maxNodes: 1, // Nodes used
  maxCost: 1, // In currency units
  maxMemory: 128, // MB
  stack: []

}

var encryptionOptions = {

  saltBytes: 256,
  digest: 'sha512',
  keyBytes: 256,
  iterations: 10000,
  algorithm: 'aes-256-cbc',
  ivBytes: 16,
  iv: crypto.randomBytes(16),
  password: crypto.randomBytes(32)

}

var vnm = {

  id: '',
  name: '',
  key: '',
  machineOptions: {},
  encryptionOptions: {},
  entity: {},
  generation: '',
  cells: [],
  edges: [],
  signatures: [],
  children: [],
  node: 0,
  v: 0,

  ops: function (options, callback) {
    return (this.compute.ops + this.storage.ops)
  },

  // Cost or marginal utility function
  cost: function (options, callback) {
    return (this.compute.cost() + this.storage.cost())
  },

  duration: function (options, callback) {
    return (this.compute.duration() + this.storage.duration())
  },

  memory: function (options, callback) {
    const used = process.memoryUsage().heapUsed / 1024 / 1024
    return Math.round(used * 100) / 100
  },

  heap: function (options, callback) {
    const heap = process.memoryUsage().heapTotal / 1024 / 1024
    return Math.round(heap * 100) / 100
  },

  rss: function (options, callback) {
    const rss = process.memoryUsage().rss / 1024 / 1024
    return Math.round(rss * 100) / 100
  },

  processes: function (options, callback) {
    return processes
  },

  // Load machine config
  init: function (options, callback) {
    if (options === undefined) {
      this.machineOptions = machineOptions
      this.defaultOptions = machineOptions
    } else {
      this.machineOptions = options
      this.defaultOptions = machineOptions
    }

    if (this.machineOptions.dimension === undefined) {
      this.machineOptions.dimension = this.defaultOptions.dimension
      this.machineOptions.cells = this.defaultOptions.cells
    }
  },

  // Secure state
  secure: function (input, options, callback) {
    if (options === undefined) {
      this.encryptionOptions = encryptionOptions
    } else {
      this.encryptionOptions = options
    }

    var keyStream = crypto.createHash(this.encryptionOptions.digest)
    keyStream.write(this.uuid())
    this.id = keyStream.digest('hex')

    keyStream = crypto.createHash(this.encryptionOptions.digest)
    keyStream.write(this.id + this.generation)
    this.key = keyStream.digest('hex')

    this.entity = input
    var entityString = cjson.stringify(this.entity)

    this.cells = new Array(this.machineOptions.dimension)
    for (var i = 0; i < this.machineOptions.dimension; i++) {
      this.cells[i] = new Array(this.machineOptions.cells)
    }

    this.signatures = new Array(this.machineOptions.dimension)
    for (var j = 0; j < this.machineOptions.dimension; j++) {
      this.signatures[j] = new Array(this.machineOptions.cells)
    }

    this.cells[0][0] = this.encrypt(entityString)

    keyStream = crypto.createHash(this.encryptionOptions.digest)
    keyStream.write(this.encryptionOptions.password + this.key + this.cells[0][0])
    this.signatures[0][0] = keyStream.digest('hex')

    return this.id
  },

  // Replicate state
  replicate: function (input, options, callback) {
    var previousSignature = this.signatures[this.v][this.node]

    this.node++

    if (this.node > this.machineOptions.cells) {
      this.node = 0
      this.v++
    }

    if (this.v > this.machineOptions.dimension) {
      this.v = 0
    }

    var inputString = cjson.stringify(input)

    this.cells[this.v][this.node] = this.encrypt(inputString)
    var keyStream = crypto.createHash(this.encryptionOptions.digest)
    keyStream.write(this.encryptionOptions.password + this.key + previousSignature + this.cells[this.v][this.node])
    this.signatures[this.v][this.node] = keyStream.digest('hex')
  },

  // Write to output
  communicate: function (input, options, callback) {
    return this.decrypt(this.cells[this.v][this.node])
  },

  // If key is available return all cells
  observe: function (input, options, callback) {

  },

  // New uuid
  uuid: function () {
    return uuid()
  },

  // Salt and hash
  hash: function (input, salt) {
    if (this.encryptionOptions === undefined) {
      this.encryptionOptions = encryptionOptions
    }

    if (!salt) {
      var saltStream = crypto.createHash(this.encryptionOptions.digest)
      saltStream.write(uuid())
      salt = saltStream.digest('hex')
    }

    var keyStream = crypto.createHash(this.encryptionOptions.digest)
    keyStream.write(input + salt)
    return {
      'hash': keyStream.digest('hex'),
      'salt': salt
    }
  },

  encrypt: function (text) {
    var iv = crypto.randomBytes(this.encryptionOptions.ivBytes)
    var encryptionKey = Buffer.from(this.encryptionOptions.password)
    var cipher = crypto.createCipheriv(this.encryptionOptions.algorithm, encryptionKey, iv)
    var encrypted = cipher.update(text)

    encrypted = Buffer.concat([encrypted, cipher.final()])
    var encryptedText = iv.toString('hex') + ':' + encrypted.toString('hex')

    return encryptedText
  },

  decrypt: function (text) {
    var textParts = text.split(':')
    var iv = Buffer.from(textParts.shift(), 'hex')
    var encryptedText = Buffer.from(textParts.join(':'), 'hex')
    var encryptionKey = Buffer.from(this.encryptionOptions.password)
    var decipher = crypto.createDecipheriv(this.encryptionOptions.algorithm, encryptionKey, iv)
    var decrypted = decipher.update(encryptedText)

    decrypted = Buffer.concat([decrypted, decipher.final()])

    return decrypted.toString()
  },

  elapsedTime: function (start) {
    var elapsed = process.hrtime(start)[1] / 1000000
    return elapsed
  },

  timestamp: function () {
    return moment().utc()
  },

  state: function () {
    var previousSignature = ''
    var integrityViolations = 0

    for (var i = 0; i < this.signatures.length; i++) {
      for (var j = 0; j < this.signatures[i].length; j++) {
        var keyStream = crypto.createHash(this.encryptionOptions.digest)
        keyStream.write(this.encryptionOptions.password + this.key + previousSignature + this.cells[i][j])
        var signature = keyStream.digest('hex')
        if (this.signatures[i][j] === signature || (this.signatures[i][j] === undefined && this.cells[i][j] === undefined)) {
          previousSignature = this.signatures[i][j]
        } else {
          integrityViolations++
        }
      }
    }

    if (this.machineOptions.maxCost === 0) {
      this.machineOptions.maxCost = 2 ^ 32
    }

    if (this.machineOptions.maxOps === 0) {
      this.machineOptions.maxOps = 2 ^ 32
    }

    var memoryLimit = (this.memory() > this.machineOptions.maxMemory)
    var nodeLimit = (this.children.length > this.machineOptions.maxNodes)

    if (this.machineOptions.debug) {
      if (this.duration() > this.machineOptions.maxDuration) {
        console.log('Max Duration exceeded')
      }

      if (this.cost() > this.machineOptions.maxCost) {
        console.log('Max cost exceeded')
      }

      if (this.cost() > this.machineOptions.maxCost) {
        console.log('Max cost exceeded')
      }

      if (this.ops() > this.machineOptions.maxOps) {
        console.log('Max ops exceeded')
      }

      if (memoryLimit) {
        console.log('Max memory exceeded')
      }

      if (nodeLimit) {
        console.log('Max node limit exceeded')
      }
    }

    if (integrityViolations > 0 || this.duration() > this.machineOptions.maxDuration || this.cost() > this.machineOptions.maxCost || this.ops() > this.machineOptions.maxOps || this.memory() > this.machineOptions.maxMemory || this.children.length > this.machineOptions.maxNodes) {
      return false
    } else {
      return true
    }
  },

  status: function () {
    return {

      'totalOps': vnm.ops(),
      'totalCost': vnm.cost(),
      'totalCostCurrency': vnm.machineOptions.currencyUnit,
      'totalDuration': vnm.duration(),
      'totalDurationUnits': vnm.machineOptions.durationUnit,
      'totalMemoryUsed': vnm.memory(),
      'totalHeapAvailable': vnm.heap(),
      'totalRSSAvailable': vnm.rss(),
      'totalNodesAvailable': vnm.processes()

    }
  },

  test: function (maxExecutions, mock, pattern, options) {
    var i = 0
    var output = []
    var results = {

      keysAdded: 0,
      keysDevared: 0,
      keysUpdated: 0,
      duration: {
        'avg': 0,
        'min': 0,
        'max': 0
      },
      cost: {
        'avg': 0,
        'min': 0,
        'max': 0
      },
      memory: {
        'avg': 0,
        'min': 0,
        'max': 0
      },
      ops: {
        'avg': 0,
        'min': 0,
        'max': 0
      },
      info: {},
      notice: {},
      warnings: {},
      errors: {}

    }

    while (i < maxExecutions) {
      var execution = mock(pattern)
      output[output.length] = execution

      try {
        results.keysAdded = results.keysAdded + diff.addedDiff(output[output.length - 1], output[output.length - 2]).keys().length
        results.keysDevared = results.keysDevared + diff.devaredDiff(output[output.length - 1], output[output.length - 2]).keys().length
        results.keysUpdated = results.keysUpdated + diff.updatedDiff(output[output.length - 1], output[output.length - 2]).keys().length
      } catch (err) {
        if (this.machineOptions.debug) {
          this.machineOptions.stack.push('Error: Key diff check failed')
        }
      }

      if (results.duration.min === 0) {
        results.duration.min = execution.duration()
      }

      results.duration.avg = results.duration.avg + execution.duration() / maxExecutions

      if (results.duration.min > execution.duration()) {
        results.duration.min = execution.duration()
      }

      if (results.duration.max < execution.duration()) {
        results.duration.max = execution.duration()
      }

      if (results.memory.min === 0) {
        results.memory.min = execution.memory()
      }

      results.memory.avg = results.memory.avg + execution.memory() / maxExecutions

      if (results.memory.min > execution.memory()) {
        results.memory.min = execution.memory()
      }

      if (results.memory.max < execution.memory()) {
        results.memory.max = execution.memory()
      }

      if (results.ops.min === 0) {
        results.ops.min = execution.ops()
      }

      results.ops.avg = results.ops.avg + execution.ops() / maxExecutions

      if (results.ops.min > execution.ops()) {
        results.ops.min = execution.ops()
      }

      if (results.ops.max < execution.ops()) {
        results.ops.max = execution.ops()
      }

      i++
    }

    return results
  }

}

vnm.chains = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 100,

  // Concurrency
  nodes: 1,

  // Target per unit expense in defined currency units
  costTarget: 0.00,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  // Module configuration
  module: {},
  input: function (i) {
    if (vnm.state()) {
      this.ops++
      this.module = i
    }
  },
  output: function (o) {
    if (vnm.state()) {
      this.ops++
      return this.module(o)
    }
  }

}

vnm.compute = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 0,

  // Concurrency
  nodes: 1,

  // Target per unit expense
  costTarget: 0.00,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  duration: function (options, callback) {
    return this.latency
  },

  // Module configuration
  module: {},
  input: function (i) {
    if (vnm.state()) {
      this.module = i
      this.ops++
    }
  },
  output: function (o) {
    if (vnm.state()) {
      var start = process.hrtime()
      var output = this.module(o)
      this.latency = this.latency + vnm.elapsedTime(start)

      this.ops++

      return output
    }
  }

}

vnm.storage = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 0,

  // Concurrency
  nodes: 1,

  // Target per unit expense in $USD
  costTarget: 0.00,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  duration: function (options, callback) {
    return this.latency
  },

  // Module configuration
  module: {},
  input: function (i) {
    if (vnm.state()) {
      this.ops++
      this.module = i
    }
  },
  output: function (o) {
    if (vnm.state()) {
      this.ops++
      var start = process.hrtime()
      var output = this.module(o)
      this.latency = this.latency + vnm.elapsedTime(start)
      return output
    }
  }

}

vnm.networking = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 100,

  // Concurrency
  nodes: 1,

  // Target per unit expense in $USD
  costTarget: 0.01,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  // Module configuration
  module: {},
  input: function (i) {
    this.ops++
    this.module = i
  },
  output: function (o) {
    this.ops++
    return this.module(o)
  }

}

vnm.messaging = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 100,

  // Concurrency
  nodes: 1,

  // Target per unit expense in $USD
  costTarget: 0.01,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  // Module configuration
  module: {},
  input: function (i) {
    this.ops++
    this.module = i
  },
  output: function (o) {
    this.ops++
    return this.module(o)
  }

}

vnm.operations = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 100,

  // Concurrency
  nodes: 1,

  // Target per unit expense in $USD
  costTarget: 0.01,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  // Module configuration
  module: {},
  input: function (i) {
    this.ops++
    this.module = i
  },
  output: function (o) {
    this.ops++
    return this.module(o)
  }

}

vnm.security = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 100,

  // Concurrency
  nodes: 1,

  // Target per unit expense in $USD
  costTarget: 0.01,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  // Module configuration
  module: {},
  input: function (i) {
    this.ops++
    this.module = i
  },
  output: function (o) {
    this.ops++
    return this.module(o)
  }

}

vnm.management = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 100,

  // Concurrency
  nodes: 1,

  // Target per unit expense in $USD
  costTarget: 0.01,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  // Module configuration
  module: {},
  input: function (i) {
    this.ops++
    this.module = i
  },
  output: function (o) {
    this.ops++
    return this.module(o)
  }

}

vnm.analysis = {

  // Operation counter
  ops: 0,

  // Values in milliseconds
  latency: 100,

  // Concurrency
  nodes: 1,

  // Target per unit expense in $USD
  costTarget: 0.01,

  // Target time in UTC or '' for immediate
  timeTarget: '',

  cost: function (options, callback) {
    return this.ops * this.costTarget
  },

  // Module configuration
  module: {},
  input: function (i) {
    this.ops++
    this.module = i
  },
  output: function (o) {
    this.ops++
    return this.module(o)
  }

}

module.exports = vnm
